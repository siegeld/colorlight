# ! [doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.37.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_cfg))] # [allow (unused_imports)] use generic :: * ; # [doc = r"Common register and bit access and modify traits"] pub mod generic ; # [cfg (feature = "rt")] extern "C" { fn uart () ; fn timer0 () ; fn ethmac () ; } # [doc (hidden)] # [repr (C)] pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , } # [cfg (feature = "rt")] # [doc (hidden)] # [no_mangle] pub static __EXTERNAL_INTERRUPTS : [Vector ; 3] = [Vector { _handler : uart } , Vector { _handler : timer0 } , Vector { _handler : ethmac } ,] ; # [doc (hidden)] pub mod interrupt ; pub use self :: interrupt :: Interrupt ; # [doc = "SPIFLASH_MMAP"] pub type SpiflashMmap = crate :: Periph < spiflash_mmap :: RegisterBlock , 0xf000_0000 > ; impl core :: fmt :: Debug for SpiflashMmap { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SpiflashMmap") . finish () } } # [doc = "SPIFLASH_MMAP"] pub mod spiflash_mmap ; # [doc = "SPIFLASH_PHY"] pub type SpiflashPhy = crate :: Periph < spiflash_phy :: RegisterBlock , 0xf000_0800 > ; impl core :: fmt :: Debug for SpiflashPhy { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SpiflashPhy") . finish () } } # [doc = "SPIFLASH_PHY"] pub mod spiflash_phy ; # [doc = "CTRL"] pub type Ctrl = crate :: Periph < ctrl :: RegisterBlock , 0xf000_1000 > ; impl core :: fmt :: Debug for Ctrl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ctrl") . finish () } } # [doc = "CTRL"] pub mod ctrl ; # [doc = "ETHMAC"] pub type Ethmac = crate :: Periph < ethmac :: RegisterBlock , 0xf000_1800 > ; impl core :: fmt :: Debug for Ethmac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethmac") . finish () } } # [doc = "ETHMAC"] pub mod ethmac ; # [doc = "ETHPHY"] pub type Ethphy = crate :: Periph < ethphy :: RegisterBlock , 0xf000_2000 > ; impl core :: fmt :: Debug for Ethphy { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethphy") . finish () } } # [doc = "ETHPHY"] pub mod ethphy ; # [doc = "HUB75_PALETTE"] pub type Hub75Palette = crate :: Periph < hub75_palette :: RegisterBlock , 0xf000_2800 > ; impl core :: fmt :: Debug for Hub75Palette { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hub75Palette") . finish () } } # [doc = "HUB75_PALETTE"] pub mod hub75_palette ; # [doc = "HUB75"] pub type Hub75 = crate :: Periph < hub75 :: RegisterBlock , 0xf000_3000 > ; impl core :: fmt :: Debug for Hub75 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hub75") . finish () } } # [doc = "HUB75"] pub mod hub75 ; # [doc = "IDENTIFIER_MEM"] pub type IdentifierMem = crate :: Periph < identifier_mem :: RegisterBlock , 0xf000_3800 > ; impl core :: fmt :: Debug for IdentifierMem { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IdentifierMem") . finish () } } # [doc = "IDENTIFIER_MEM"] pub mod identifier_mem ; # [doc = "SDRAM"] pub type Sdram = crate :: Periph < sdram :: RegisterBlock , 0xf000_4000 > ; impl core :: fmt :: Debug for Sdram { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sdram") . finish () } } # [doc = "SDRAM"] pub mod sdram ; # [doc = "TIMER0"] pub type Timer0 = crate :: Periph < timer0 :: RegisterBlock , 0xf000_4800 > ; impl core :: fmt :: Debug for Timer0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer0") . finish () } } # [doc = "TIMER0"] pub mod timer0 ; # [doc = "UART"] pub type Uart = crate :: Periph < uart :: RegisterBlock , 0xf000_5000 > ; impl core :: fmt :: Debug for Uart { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart") . finish () } } # [doc = "UART"] pub mod uart ; # [doc = "ETHMEM"] pub type Ethmem = crate :: Periph < ethmem :: RegisterBlock , 0x8000_0000 > ; impl core :: fmt :: Debug for Ethmem { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethmem") . finish () } } # [doc = "ETHMEM"] pub mod ethmem ; # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "SPIFLASH_MMAP"] pub spiflash_mmap : SpiflashMmap , # [doc = "SPIFLASH_PHY"] pub spiflash_phy : SpiflashPhy , # [doc = "CTRL"] pub ctrl : Ctrl , # [doc = "ETHMAC"] pub ethmac : Ethmac , # [doc = "ETHPHY"] pub ethphy : Ethphy , # [doc = "HUB75_PALETTE"] pub hub75_palette : Hub75Palette , # [doc = "HUB75"] pub hub75 : Hub75 , # [doc = "IDENTIFIER_MEM"] pub identifier_mem : IdentifierMem , # [doc = "SDRAM"] pub sdram : Sdram , # [doc = "TIMER0"] pub timer0 : Timer0 , # [doc = "UART"] pub uart : Uart , # [doc = "ETHMEM"] pub ethmem : Ethmem , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."] # [cfg (feature = "critical-section")] # [inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Each of the returned peripherals must be used at most once."] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { spiflash_mmap : SpiflashMmap :: steal () , spiflash_phy : SpiflashPhy :: steal () , ctrl : Ctrl :: steal () , ethmac : Ethmac :: steal () , ethphy : Ethphy :: steal () , hub75_palette : Hub75Palette :: steal () , hub75 : Hub75 :: steal () , identifier_mem : IdentifierMem :: steal () , sdram : Sdram :: steal () , timer0 : Timer0 :: steal () , uart : Uart :: steal () , ethmem : Ethmem :: steal () , } } }